内容回顾：
    1.网络协议
        osi七层  应表会传网数物

        tcp/ip五层

        传输层：TCP/UDP协议
        TCP：面向连接，消息可靠，相对效率低，消息格式面向流的，无消息保护边界
        UDP：无连接，消息不可靠，效率低，面向包的，有消息保护边界

        tcp
            三次握手：

            四个握手：
    2.tcp协议下的socket
      udp协议下的socket
今日内容：
    tcp：属于长连接，与一个客户端进行连接之后，其他的客户端要等待，要连接另一个，必须优雅的断开前面这一个客户端的连接

    允许地址重用的作用：在bind IP地址和端口之前加上，server.setsockopt(socket.SOCK_SOCKET,socket.SO_REUSEADDR,1)  #允许（IP地址和端口）地址重用
    缓冲区：暂时存放，防止你的程序在发送的过程卡住，提高代码运行的效率
        输入缓冲区  #recv
        输出缓冲区  #send
    粘包（tcp的两种粘包现象）
        1.连续发送小的数据，并且每次发送之间的时间间隔很短（两个消息在缓冲区黏在一起了）
            原因是TCP为了传输效率，做了一个优化算法，减少连续的小包发送（因为每个消息被包裹以后，都会有两个过程：
                1.组包 2.拆包）
        2.第一次发送的数据比我客户端设置的一次接收消息的大小要大，那么接收不完，第二次在接收的时候，就会将第一次剩余的消息接收到

        粘包的根本原因是：双方不知道双方发送消息的大小
    解决方案一：
        发送消息之前，先计算要发送消息的长度，然后先将消息长度发送过去，对方给你回一个确认长度的信息，
        然后根据接收到的信息长度来修改自己一次接收消息的大小
        这个过程就多了一次交互